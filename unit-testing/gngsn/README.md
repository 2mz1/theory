## Unit Testing
<small>Author: [Gyeongsun Park](https://github.com/gngsn)</small>

<br/>

<details>
<summary><b>Overview</b></summary>

<br/>
<img src="image/overview.png" width="1618">
<br/>
</details>

<br/>

### _Part 1:_
<details>
<summary><b>CHAPTER 01. 단위 테스트의 목표</b></summary>

<br/>
<a href="https://github.com/2mz1/theory/tree/gngsn/unit-testing/gngsn/chapter01"> 🔗 link </a>
<br/>

**TL;DR**
- **성공적인 테스트 스위트**
    - 1#. 개발 주기에 통합되어 있음
    - 2#. 코드베이스에서 가장 중요한 부분 - _비즈니스 로직 (도메인 모델)_ - 만을 대상으로 함
    - 3#. 최소 유지비로 최대 가치를 끌어냄 (가치 있는 테스트를 식별하고, 작성하라)
- **비용 편익 분석**을 배우고 **안티 패턴**을 피하는 방법을 배워라.
    - **비용 편익 분석 (cost-benefit analysis)**: 여러 가지 대안에 대해 비용과 이익을 분석해서 가장 효과적인 대안을 찾는 방법론.
    - **안티 패턴(anti-pattern)**: 처음에는 괜찮은 것 같지만 미래에 문제를 야기하는 패턴
- 테스트의 장점
    - **소프트웨어 엔트로피(software entropy)** 를 막을 수 있음
        - 지속적인 정리와 리팩터링 등 적절한 관리를 하지 않고 방치하면 시스템이 점점 더 복잡해지고 무질서해짐.
        - 소프트웨어 품질을 떨어뜨리는 코드의 형태.
    - **회귀(regression)에 대한 보험을 제공**
        - **소프트웨어 버그**와 **회귀**는 동의어
          **테스트의 가치와 유지 비용을 모두 고려해야 함**
    - 기반 코드를 리팩터링할 때 **테스트도 리팩터링**하라
    - 각 **코드 변경 시 테스트를 실행**하라
    - **테스트가 잘못된 경고를 발생시킬 경우 처리**하라
    - 기반 코드의 동작을 이해하려고 할 때는 **테스트를 읽는 데 시간을 투자**하라
- 테스트도 **애플리케이션의 정확성을 보장**을 목표하는 **코드베이스**의 일부로 봐야 함
- $`코드\ 커버리지\ (테스트\ 커버리지) = \frac{제품\ 코드\ 라인\ 수}{전체\ 라인\ 수}`$
- $`분기\ 커버리지 = \frac{통과\ 분기}{전체\ 분기\ 수}`$
- **커버리지 지표에 관한 문제점**
    - 1#. 가능한 모든 결과를 검증한다고 보증할 수 없음
    - 2#. 외부 라이브러리 코드 경로를 고려할 수 없음
- **시스템의 핵심 부분은 커버리지를 높게 두는 것이 좋지만, 이 높은 수준을 요구 사항으로 삼는 것은 좋지 않음.**

<br/>
</details>
<details>
<summary><b>CHAPTER 02. 단위 테스트란 무엇인가</b></summary>

<br/>
<a href="https://github.com/2mz1/theory/tree/gngsn/unit-testing/gngsn/chapter02"> 🔗 link </a>
<br/>

**TL;DR**
- **단위 테스트**
    - ① 단일 동작 단위를 검증 / ② 빠르게 수행  / ③ 다른 테스트와 격리하여 처리
- **런던파** _London School_
    - **테스트 대상 시스템에서 협력자를 격리**
    - **코드**나 **SUT(단일 클래스)** 단위의 테스트
- **고전파** _Classic School_
    - **단위 테스트끼리 격리**
    - **동작** 단위의 테스트
- **테스트 대역**: 테스트를 목적으로 객체를 특정 형태로 대체
- **AAA Pattern**: Assert, Act, Assert Pattern. 준비-실행-검증 패턴.
- **SUT vs MUT**
    - **SUT**: System Under Test. 테스트 검증 시스템, <b>클래스의 전체</b>를 가리킴
    - **MUT**: Method Under Test. 테스트 대상 메서드. 테스트에서 호출한 SUT의 <b>메서드</b>를 가리킴
- **테스트 대역 vs Mock**
    - **테스트 대역**: 실행과 관련 없이 모든 종류의 가짜 의존성을 설명하는 포괄적인 용어
    - **Mock**: 테스트 대상 시스템과 협력자 간의 상호 작용을 검사할 수 있는 특별한 테스트 대역
- **의존성**
    - **공유 의존성** _shared dependecy_: 동일 프로세스 내 영향을 미칠 수 있는 의존성. (ex. `static mutable field`, 데이터베이스)
    - **비공개 의존성** _private dependency_: 공유하지 않는 의존성
    - **프로세스 외부 의존성** _out-of-process dependency_: 애플리케이션 실행 프로세스 외부에서 실행되는 의존성
    - **싱글턴 의존성** _singleton_: **보통은 공유 의존성**. 하지만, 각 테스트 별 새 인스턴스 만들 수 있으면 **공유 의존성이 아님**
    - **설정 클래스** _configuration class_: 일반적으로 한 개인 공유 클래스. 하지만, 다른 모든 의존성이 SUT에 주입되면 새 인스턴스 생성 가능
    - **휘발성 의존성** _volatile dependency_: 런타임 환경의 설정 및 구성 요구 or 비결정적 동작 (각 호출에 대해 다른 결과를 제공) 포함
- <table><tr><th>런던파 이점</th><th>고전파를 선호하는 필자의 견해</th></tr><tr><td>세밀한 테스트로 입자성이 좋음</td><td>테스트는 단위가 아닌 동작 단위를 검증해야 함</td></tr><tr><td>연결된 클래스 그래프가 커져도 테스트가 쉬움 (테스트 대역으로 대체됨)</td><td>애초에 상호 연결된 클래스의 크고 복잡한 그래프를 갖지 않아야 함</td></tr><tr><td>테스트 실패 시 어떤 기능이 실패했는지 알 수 있음</td><td>큰 이점은 아님. 마지막 수정한 부분이 버그의 원인일 것</td></tr></table>
- **테스트 주도 개발**: TDD는 테스트에 의존해 프로젝트 개발을 추진하는 소프트웨어 개발 프로세스
    1. 추가할 기능과 예상 동작의 실패 테스트 작성
    2. 테스트를 통과할 코드 작성. 코드가 깨끗하거나 명쾌할 필요는 없음
    3. 코드 리팩터링. 통과 테스트 보호하에 코드를 안전하게 정리
- **통합 테스트**: 단위 테스트 기준 중 하나 이상을 충족하지 못하는 테스트
- **엔드 투 엔드 테스트**: 애플리케이션과 함께 작동하는 프로세스 외부 의존성의 전부 또는 대부분에 직접 접근

<br/>
</details>
<details>
<summary><b>CHAPTER 03. 단위테스트의 구조</b></summary>

<br/>
<a href="https://github.com/2mz1/theory/tree/gngsn/unit-testing/gngsn/chapter03"> 🔗 link </a>
<br/>

**TL;DR**
- **AAA 패턴**: Arrange, Act, Assert Pattern. _준비 · 실행 · 검증_
  - **① 준비 구절**: SUT과 해당 의존성을 원하는 상태로 만듦
  - **② 실행 구절**: SUT에서 메서드를 호출 · 준비된 의존성을 전달하며 · 출력 값 캡처
  - **③ 검증 구정**: 결과 검증
  - ‘준비 or 실행 or 검증’ 중 여러 번 실행해야 한다면: **여러 동작 단위를 검증한다는 표시** → 여러 개로 분리
  - **구절 표기 주석 제거**: 준비 및 검증 구절에 빈 줄을 추가해야 할 때라면 주석을 유지하고, 아니라면 주석 제거
- AAA 패턴 코드의 크기: **준비 구절 ≥ 실행 구절 + 검증 구절**
  - 준비 구절이 너무 크면 `private method` 나 `factory method`로 도출 가능
- **`if` 문이 있는 단위 테스트**는 안티 패턴
- 실행 구절이 **한 줄 이상인 경우**를 경계하라
  - **불변 위반** invatiant violation: ex. 각기 다른 메서드를 실행하는데 서로의 결과에 의존해 이상한 결과값을 도출되는 것 → 단일한 공개 메서드여야 하는 메서드
  - **캡슐화**: 잠재적인 불변 위반으로부터 코드를 보호하는 것
- SUT의 이름을 <b>`sut`</b>로 지정해 구별해라
- **Test Fixture 재사용 방법**
  1. 안티 패턴: 생성자에서 Test Fixture 초기화
  2. 테스트 클래스에 비공개 팩토리 메서드 _private factory method_ 를 두는 것
- **읽기 쉬운 테스트 이름**: 간단하고 쉬운 영어 명명
  - 엄격한 테스트 명명 정책을 피해라
  - 도메인 전문가에게 시나리오를 설명하는 것처럼 지어라
  - 단어를 밑줄(`_`)로 구분하라
  - 테스트 명 내 테스트 대상 메서드 이름을 포함하지 마라
  - *`should be`* 는 또 다른 안티 패턴 네이밍
- 매개변수화된 테스트 _parameterized test_ 를 통해 유사한 사실을 단일한 메서드로 묶을 수 있음
  - **긍정 케이스 vs. 부정 케이스를 분리**하되, 동작이 너무 복잡하면 사용 금지
- **검증문 라이브러리** 사용: Java에는 `assertJ` 가 대표적

<br/>
</details>
<br/>

### _Part 2:_
<details>
<summary><b>CHAPTER 04. 좋은 단위 테스트의 4대 요소</b></summary>

<br/>
<a href="https://github.com/2mz1/theory/tree/gngsn/unit-testing/gngsn/chapter04"> 🔗 link </a>
<br/>

**TL;DR**
- **회귀**: 소프트웨어 버그, 코드를 수정한 후 (일반적으로 새 기능을 출시한 후) 기능이 의도한 대로 작동하지 않는 경우
- **리팩터링**
  - 식별할 수 있는 동작을 수정하지 않고 기존 코드를 변경하는 것
  - 의도: 코드의 비기능적 특징 개선. 가독성을 높이고 복잡도를 낮추는 것
  - 리팩터링 내성을 높이는 방법: SUT 구현 세부 사항과 테스트 간의 결합도를 낮추는 것뿐
- **코드 정확도**와 **테스트 결과**
  - **참 음성**: True negatives. 기능이 의도 대로 작동할 떄, 테스트가 통과하도록 올바른 추론한 경우
  - **참 양성**: True positives. 기능이 제대로 작동하지 않을 때, 테스트가 실패하도록 올바른 추론한 경우 ← 단위 테스트의 핵심
  - **거짓 음성**: False negatives. 기능이 제대로 작동하지 않을 때, 테스트가 통과하도록 잘못된 추론한 경우
  - **거짓 양성**: False positives. 기능이 의도 대로 작동할 때, 테스트가 실패하도록 잘못된 추론한 경우 ← 허위 경보. 리팩터링 내성을 통해 방지 가능
- **정확도 지표**
  - $`테스트\ 정확도 = \frac{신호(발견된\ 버그\ 수)}{소음(허위\ 경보\ 발생\ 수)}`$
  - 테스트의 정확도를 높이는 방법: ① 신호를 증가시키거나, ② 소음을 줄이는 것
- 좋은 단위 테스트의 4대 특성: 아래 네 가지 특성의 곱
  - **회귀 방지** / **리팩터링 내성** / **빠른 피드백** / **유지 보수성**
  - 곱셈 법칙에 의해 어떤 특성이라도 `0`이 되면 전체가 `0`이 됨
- 좋은 단위 테스트의 특성 - **회귀 방지** / **리팩터링 내성** / **빠른 피드백** - 은 **상호 배타적**
  - **리팩터링 내성을 최대한 많이 갖는 것을 목표** + 테스트가 얼마나 버그를 잘 찾아내는지와 얼마나 빠른지 사이의 절충안
- 최소 필수값에 대해 상당히 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라
- **테스트 피라미드**
  - 1층: 단위 테스트 > 2층: 통합 테스트 > 3층: 엔드 투 엔드 테스트
- 화이트박스 테스트 대신 **블랙박스 테스트를 기본적으로 선택**하라
  - **블랙박스 테스트**: 시스템의 내부 구조를 몰라도 시스템의 기능을 검사할 수 있는 소프트웨어 테스트 방법
  - **화이트박스 테스트**: 내부 작업 검증

<br/>
</details>
