# Chapter4 설계 품질과 트레이드오프



- 객체지향 설계의 핵심은 역할, 책임, 협력이다.
- 객체지향 설계란 올바른 객체에게 올바른 책임을 할당해서 낮은 결합도와 높은 응지도를 창조 하는 활동이다.
- 객체지향 설꼐의 핵심은 책임이다.
- 책임을 할당하는 작업이 응집도와 결합도와 같은 설계 품질과 깊이 연관돼 있다.
- 훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것이다.



# 데이터 중심의 영화 예매 시스템

**객체지향 설계의 두 가지 방법**

1. 상태를 분할의 중심축으로 삼음
    1. 일반적으로 객체의 상태는 객체가 저장해야 하는 데이터 집합을 의미하기 때문에 `상태` 와 `데이터` 를 동일한 의미로 사용
2. 책임을 분할의 중심축으로 삼음

> 훌륭한 객체지향 설계는 데이터가 아닌 책임에 초점을 맞춰야함
> 



# 설계 트레이드 오프

## 캡슐화

- 상태와 행동을 하나의 객체안에 모으는 이유 객체 내부 구현을 외부로 부터 감추기 위해서
- `구현` 이란 나중에 변경될 가능성 높은 어떤 것을 가리킴
- 변경 가능성이 높은 부분은 내부에 숨기고 외부에는 상대적으로 안정적인 부분만 공개
- 변경될 가능성이 높은 부분을 `구현` 이라 하고 안정적인 부분을 `인터페이스` 라고함
- 객체지향에서 가장 중요한 원리는 `캡슐화` 다

## 응집도 와 결합도

**응집도**

- `응집도` 는 모듈에 포함된 내부 요소들이 연관돼 있는 정도를 나타냄
- 모듈 내의 요소들이 하나의 목적을 위해 긴밀하게 협력한다면 모듈은 높은 응집도를 가짐
- 모듈 내의 요소들이 서로 다른 목적을 추구하면 그 모듈은 낮은 응집도임

**결합도**

- `결합도` 는 의존성의 정도를 나타내며 다른 모듈에 대해 얼마나 많은 지식을 갖고 있는지를 나타내는 척도
- 어떤 모듈이 다른 모듈에 대해 너무 자세한 부분까지 알고 있다면 두 모듈은 높은 결합도를 가진다.
- 어떤 모듈이 다른 모듈에 대해 꼭 필요한 지식만 알고 있다면 두 모듈은 낮은 결합도를 가진다.
    - 인터페이스



# 데이터 중심의 영화 예매 시스템의 문제점

데이터 중심의 설계가 잘못된점

- 캡슐화 위반
- 높은 결합도
- 낮은 응집도



# 자율적인 객체를 향해

## 캡슐화를 지켜라

캡슐화는 설계의 제1 원리다.

**사각형을 표현하는거로 드는 예시**

```java
class Rectangle {
 private int left;
 private int top;
 private int right;
 private int bottom;
 public Rectangle(int left, int top, int right, int bottom) {
	 this.left = left;
	 this.top = top;
	 this.right = right;
	 this.bottom = bottom;
 }
 public int getLeft() { return left; }
 public void setLeft(int left) { this.left = left; }
 public int getTop() { return top; }
 public void setTop(int top) { this.top = top; }
 public int getRight() { return right; }
 public void setRight(int right) { this.right = right; }
 public int getBottom() { return bottom; }
 public void setBottom(int bottom) { this.bottom = bottom; }
}
```

```java
class AnyClass {
 void anyMethod(Rectangle rectangle, int multiple) {
 rectangle.setRight(rectangle.getRight() * multiple);
 rectangle.setBottom(rectangle.getBottom() * multiple);
 ...
 }
}
```

**문제점**

- 코드 중복이 발생할 확률이 높음
    - 다른 곳에서도 사각형의 너비와 높이를 증가시키는 코드가 필요하다면 `getRight` `getBottom` 메소드를 호출하고 해당 메소드로 값을 변경하는 유사한 코드가 존재할 것이다.
- `변경에 취약` 해짐

## 스스로 자신의 데이터를 책임지는 객체

상태와 행동을 객체라는 하나의 단위로 묶는 이유는 객체 `스스로` 자신의 상태를 처리할 수 있게 하기 위해서다.

따라서 객체를 설계할 때 `이 객체가 어떤 데이터를 포함해야 하는가` 를 아래 두개의 개별적인 질문으로 분리해야 한다.

- 이 객체가 어떤 데이터를 포함해야 하는가?
- 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?

> Web 서비스에서 DB 에 관련된 도메인 객체가 `스스로` 자신의 데이터를 책임지며 상태를 처리하는 방식을 `풍부한 도메인 모델` 설계라고도 부른다
`토비의 스프링` 에서도 해당 내용을 다루고 있다.
> 



# 데이터 중심 설계의 문제점

- 데이터 중심의 설계는 본질적으로 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
- 데이터 중심의 설계에서는 협력이라는 문맥을 고려하지 않고 객체를 고립시킨 채 오퍼레이션을 결정한다.

## 데이터 중심 설계는 객체의 행동보다는 상태의 초점을 맞춘다.

- 이 객체가 포함해야 하는 데이터가 무엇인가? 를 먼저 생각 하게됨
- 너무 이른 시기에 내부 구현에 초점을 맞추게 됨
- 데이터 중심 설계에 익숙해지면 `절차적 프로그래밍` 방식에 따르게됨
    - 객체가 스스로 책임과 상태를 관리하지 않게하고 특정 클래스의 메소드가 모든 로직을 수행함 ( 각 객체를 호출해서 데이터를 꺼내가지고 `절차적`으로 수행하게 됨 )



# 개인 적인 느낀점

개발을 하다 보면 여러 도구들을 적절하게 조합해서 사용하게 되고 여러가지 패턴을 가지고 사용하게 된다 

**내가 느끼기에 문제점들**

1. Lombok
    1. 너무 많은 일을 쉽게 하도록 도와줌 ex) `@Getter` `@Setter` 등등 그냥 편하게 객체에 작성하고 가는 경우가 많음
    2. 기타 롬복의 편한 어노테이션들
2. Mybatis
    1. DB (데이터) 관점으로 개발하게 되어 오브젝트에서 말하는 진정한 `객체지향` 설계를 하기가 힘들어짐
3. Spring 개발 방법
    1. `Controller` `Service` `DAO or Repository` MVC 패턴을 사용할 경우 객체는 단순 데이터 `저장` 용도 모든 로직을 서비스에서 처리하게 되어 `절차 지향` 적으로 코딩을 하게 되는거 같음

**그러면 어떻게 사용하는게 좋을까?**

1. Lombok
    1. 최소한 필요한 어노테이션만 사용하자 `@Data` 같은 어노테이션은 사용을 지양하자
2. Mybatis → JPA
    1. JPA 를 사용하자
    2. `성능` 적인 부분은 고려해야할게 정말 많지만 초기에 잘 정하고가면 괜찮을거 같다.
    3. JPA 를 사용함으로써 `도메인` 객체 내에서 `스스로 데이터 와 상태` 를 관리하도록 하고 `도메인` 객체에서 스스로 데이터를 변경 및 관리하도록 하여 `객체지향` 설계를 지칠 수 있으며
    `풍부한 도메인 개발` 을 할 수 있게 된다.
3. Spring 개발 방법
    1. MVC 패턴이 나쁜게 아니다! Service 에서 모든 로직을 가지고 있는게 나쁜거다!
    2. JPA 와 Lombok 을 적절하게 사용하여 Service 에서는 각 도메인을 호출하여 메시지를 전달해주는 방식을 개발을 하자
